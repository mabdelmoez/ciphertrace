[MAIN]
ASID = 30249000

[COMMANDS] # Works without the python
TesterCmd = python tester/celementfind_test.py --testdata __testdata__/aes128/test_celementfind_records --celement scheduling --moduledir analyzer
RandometerCmd = python randometer/randometer.py --readgram __testdata__/aes128/unigram_mem_read_report.bin --writegram __testdata__/aes128/unigram_mem_write_report.bin
AnalyzerCmd = python analyzer/analyzer.py --stats __testdata__/aes128/func_stats --sym __testdata__/aes128/func_db --stack functionstack --conf False --verbose False --outprefix aes128
VerifierLightCmd = python verifier/verifierlight.py --tapdir __testdata__/aes128/ --matchesfile __testdata__/aes128/enc_string_matches.txt
VerifierCmd = python verifier/verifier.py --searchterms __testdata__/aes128/searchterms.txt --readbuffers __testdata__/aes128/read_tap_buffers.txt.gz --writebuffers __testdata__/aes128/write_tap_buffers.txt.gz
VerifierHeavyCmd = python verifier/verifierheavy.py --datdir __testdata__/aes128/ --searchterms __testdata__/aes128/searchterms.txt
VisualizerCmd = python visualizer/visualizer.py --graph __testdata__/aes128/aes128_76351fb7.graph --sym __testdata__/aes128/func_db

# TODO: uncomment EntReadMask and EntWriteMask from Randometer code, to make the options available. 
[RANDOMETER] # Entropy is not taken into consideration (by default). We are looking for callers that have high-randomness (low chi-square) write buffers and low randomness on the read.
EntReadMask = "> 0"
EntWriteMask = "> 0"
RandReadMask = "> 10000"
RandWriteMask = "< 1000"

# AConfig -> filtering criteria: mainrecord=maxexecs, stacksize=3, compc_write_entropy=1.0
[Analyzer] # A first caller execusion only runs over the first entry in the list of output callers from the randometer i.e., from randometer.out
FirstCallerExecusion = true
Config = "maxexecs, 3, 1.0"

[Visualizer]
ConnDetails = "bolt://localhost:7687, neo4j, mypassword"

# DataIndex, where the data byte can be found in the tap buffers file, differ per OS
[Verifier]
DataIndex = 23